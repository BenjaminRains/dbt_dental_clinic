# DBT model metadata and lineage endpoints
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from sqlalchemy import text
from typing import List, Optional, Dict, Any
from datetime import datetime

from database import get_db
from api_types import DBTModelMetadata, DBTMetricLineage, MetricLineageInfo

router = APIRouter(
    prefix="/dbt",
    tags=["dbt-metadata"],
    responses={404: {"description": "Not found"}},
)

# Predefined metric lineage mapping based on current DBT models
METRIC_LINEAGE_MAPPING = {
    "revenue_lost": {
        "source_model": "mart_revenue_lost",
        "source_schema": "raw_marts",
        "calculation_description": "Sum of lost revenue from missed appointments and billing issues",
        "data_freshness": "Daily",
        "business_definition": "Total revenue lost due to missed appointments, billing errors, and collection issues",
        "dependencies": ["fact_appointment", "fact_claim", "fact_payment"],
        "last_updated": datetime.now()
    },
    "recovery_potential": {
        "source_model": "mart_revenue_lost", 
        "source_schema": "raw_marts",
        "calculation_description": "Sum of estimated recoverable amounts from revenue opportunities",
        "data_freshness": "Daily",
        "business_definition": "Potential revenue that can be recovered through follow-up actions",
        "dependencies": ["fact_appointment", "fact_claim", "fact_payment"],
        "last_updated": datetime.now()
    },
    "active_providers": {
        "source_model": "mart_provider_performance",
        "source_schema": "raw_marts", 
        "calculation_description": "Count of distinct providers with appointments in the period",
        "data_freshness": "Daily",
        "business_definition": "Number of providers who have scheduled or completed appointments",
        "dependencies": ["fact_appointment", "dim_provider"],
        "last_updated": datetime.now()
    },
    "total_production": {
        "source_model": "mart_provider_performance",
        "source_schema": "raw_marts",
        "calculation_description": "Sum of total production amounts by provider",
        "data_freshness": "Daily", 
        "business_definition": "Total production value generated by providers",
        "dependencies": ["fact_appointment", "fact_claim", "dim_provider"],
        "last_updated": datetime.now()
    },
    "total_collection": {
        "source_model": "mart_provider_performance",
        "source_schema": "raw_marts",
        "calculation_description": "Sum of total collections by provider",
        "data_freshness": "Daily",
        "business_definition": "Total amount collected from patients and insurance",
        "dependencies": ["fact_payment", "fact_claim", "dim_provider"],
        "last_updated": datetime.now()
    },
    "collection_rate": {
        "source_model": "mart_provider_performance", 
        "source_schema": "raw_marts",
        "calculation_description": "Average collection efficiency rate across providers",
        "data_freshness": "Daily",
        "business_definition": "Percentage of production that has been collected",
        "dependencies": ["fact_payment", "fact_claim", "dim_provider"],
        "last_updated": datetime.now()
    },
    "completion_rate": {
        "source_model": "mart_provider_performance",
        "source_schema": "raw_marts", 
        "calculation_description": "Average appointment completion rate across providers",
        "data_freshness": "Daily",
        "business_definition": "Percentage of scheduled appointments that were completed",
        "dependencies": ["fact_appointment", "dim_provider"],
        "last_updated": datetime.now()
    },
    "no_show_rate": {
        "source_model": "mart_provider_performance",
        "source_schema": "raw_marts",
        "calculation_description": "Average no-show rate across providers", 
        "data_freshness": "Daily",
        "business_definition": "Percentage of appointments where patients did not show up",
        "dependencies": ["fact_appointment", "dim_provider"],
        "last_updated": datetime.now()
    },
    "total_appointments": {
        "source_model": "mart_provider_performance",
        "source_schema": "raw_marts",
        "calculation_description": "Sum of total appointments across all providers",
        "data_freshness": "Daily", 
        "business_definition": "Total number of scheduled appointments",
        "dependencies": ["fact_appointment", "dim_provider"],
        "last_updated": datetime.now()
    },
    "total_unique_patients": {
        "source_model": "mart_provider_performance",
        "source_schema": "raw_marts",
        "calculation_description": "Count of unique patients seen by providers",
        "data_freshness": "Daily",
        "business_definition": "Total number of unique patients with appointments",
        "dependencies": ["fact_appointment", "dim_patient", "dim_provider"],
        "last_updated": datetime.now()
    }
}

@router.get("/model-metadata/{model_name}", response_model=DBTModelMetadata)
async def get_model_metadata(
    model_name: str,
    db: Session = Depends(get_db)
):
    """Get DBT model metadata and lineage information"""
    
    # Query the DBT model metadata from the database
    query = """
    SELECT 
        model_name,
        model_type,
        schema_name,
        description,
        business_context,
        technical_specs,
        dependencies,
        downstream_models,
        data_quality_notes,
        refresh_frequency,
        grain_definition,
        source_tables,
        created_at,
        updated_at,
        is_active
    FROM dbt_model_metadata 
    WHERE model_name = :model_name AND is_active = true
    """
    
    result = db.execute(text(query), {"model_name": model_name}).fetchone()
    
    if not result:
        raise HTTPException(status_code=404, detail=f"Model {model_name} not found")
    
    return DBTModelMetadata(
        model_name=result.model_name,
        model_type=result.model_type,
        schema_name=result.schema_name,
        description=result.description,
        business_context=result.business_context,
        technical_specs=result.technical_specs,
        dependencies=result.dependencies,
        downstream_models=result.downstream_models,
        data_quality_notes=result.data_quality_notes,
        refresh_frequency=result.refresh_frequency,
        grain_definition=result.grain_definition,
        source_tables=result.source_tables,
        created_at=result.created_at,
        updated_at=result.updated_at,
        is_active=result.is_active
    )

@router.get("/metric-lineage/{metric_name}", response_model=MetricLineageInfo)
async def get_metric_lineage(
    metric_name: str,
    db: Session = Depends(get_db)
):
    """Get lineage information for a specific metric"""
    
    if metric_name not in METRIC_LINEAGE_MAPPING:
        raise HTTPException(status_code=404, detail=f"Metric {metric_name} not found")
    
    lineage_data = METRIC_LINEAGE_MAPPING[metric_name]
    
    return MetricLineageInfo(
        metric_name=metric_name,
        source_model=lineage_data["source_model"],
        source_schema=lineage_data["source_schema"],
        calculation_description=lineage_data["calculation_description"],
        data_freshness=lineage_data["data_freshness"],
        business_definition=lineage_data["business_definition"],
        dependencies=lineage_data["dependencies"],
        last_updated=lineage_data["last_updated"]
    )

@router.get("/metric-lineage", response_model=List[MetricLineageInfo])
async def get_all_metric_lineage(
    db: Session = Depends(get_db)
):
    """Get lineage information for all available metrics"""
    
    return [
        MetricLineageInfo(
            metric_name=metric_name,
            source_model=lineage_data["source_model"],
            source_schema=lineage_data["source_schema"],
            calculation_description=lineage_data["calculation_description"],
            data_freshness=lineage_data["data_freshness"],
            business_definition=lineage_data["business_definition"],
            dependencies=lineage_data["dependencies"],
            last_updated=lineage_data["last_updated"]
        )
        for metric_name, lineage_data in METRIC_LINEAGE_MAPPING.items()
    ]

@router.get("/models", response_model=List[DBTModelMetadata])
async def get_all_models(
    model_type: Optional[str] = Query(None, description="Filter by model type"),
    schema_name: Optional[str] = Query(None, description="Filter by schema name"),
    db: Session = Depends(get_db)
):
    """Get all DBT model metadata with optional filtering"""
    
    query = """
    SELECT 
        model_name,
        model_type,
        schema_name,
        description,
        business_context,
        technical_specs,
        dependencies,
        downstream_models,
        data_quality_notes,
        refresh_frequency,
        grain_definition,
        source_tables,
        created_at,
        updated_at,
        is_active
    FROM dbt_model_metadata 
    WHERE is_active = true
    """
    
    params = {}
    if model_type:
        query += " AND model_type = :model_type"
        params["model_type"] = model_type
    if schema_name:
        query += " AND schema_name = :schema_name"
        params["schema_name"] = schema_name
    
    query += " ORDER BY model_type, model_name"
    
    results = db.execute(text(query), params).fetchall()
    
    return [
        DBTModelMetadata(
            model_name=row.model_name,
            model_type=row.model_type,
            schema_name=row.schema_name,
            description=row.description,
            business_context=row.business_context,
            technical_specs=row.technical_specs,
            dependencies=row.dependencies,
            downstream_models=row.downstream_models,
            data_quality_notes=row.data_quality_notes,
            refresh_frequency=row.refresh_frequency,
            grain_definition=row.grain_definition,
            source_tables=row.source_tables,
            created_at=row.created_at,
            updated_at=row.updated_at,
            is_active=row.is_active
        )
        for row in results
    ]
